{"version":3,"sources":["index.js","event-bus.js","event-store.js","utils.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = {\n  HYEventBus: require('./event-bus'),\n  HYEventStore: require('./event-store')\n}\n","class HYEventBus {\n  constructor() {\n    this.eventBus = {}\n  }\n\n  on(eventName, eventCallback, thisArg) {\n    if (typeof eventName !== \"string\") {\n      throw new TypeError(\"the event name must be string type\")\n    }\n\n    if (typeof eventCallback !== \"function\") {\n      throw new TypeError(\"the event callback must be function type\")\n    }\n    \n    let hanlders = this.eventBus[eventName]\n    if (!hanlders) {\n      hanlders = []\n      this.eventBus[eventName] = hanlders\n    }\n\n    hanlders.push({\n      eventCallback,\n      thisArg\n    })\n    return this\n  }\n\n  once(eventName, eventCallback, thisArg) {\n    if (typeof eventName !== \"string\") {\n      throw new TypeError(\"the event name must be string type\")\n    }\n\n    if (typeof eventCallback !== \"function\") {\n      throw new TypeError(\"the event callback must be function type\")\n    }\n    \n    const tempCallback = (...payload) => {\n      this.off(eventName, tempCallback)\n      eventCallback.apply(thisArg, payload)\n    }\n\n    return this.on(eventName, tempCallback, thisArg)\n  }\n\n  emit(eventName, ...payload) {\n    if (typeof eventName !== \"string\") {\n      throw new TypeError(\"the event name must be string type\")\n    }\n\n    const handlers = this.eventBus[eventName] || []\n    handlers.forEach(handler => {\n      handler.eventCallback.apply(handler.thisArg, payload)\n    })\n    return this\n  }\n\n  off(eventName, eventCallback) {\n    if (typeof eventName !== \"string\") {\n      throw new TypeError(\"the event name must be string type\")\n    }\n\n    if (typeof eventCallback !== \"function\") {\n      throw new TypeError(\"the event callback must be function type\")\n    }\n\n    const handlers = this.eventBus[eventName]\n    if (handlers && eventCallback) {\n      const newHandlers = [...handlers]\n      for (let i = 0; i < newHandlers.length; i++) {\n        const handler = newHandlers[i]\n        if (handler.eventCallback === eventCallback) {\n          const index = handlers.indexOf(handler)\n          handlers.splice(index, 1)\n        }\n      }\n    }\n\n    if (handlers.length === 0) {\n      delete this.eventBus[eventName]\n    }\n  }\n}\n\nmodule.exports = HYEventBus\n","const EventBus = require(\"./event-bus\")\nconst { isObject } = require('./utils')\n\nclass HYEventStore {\n  constructor(options) {\n    if (!isObject(options.state)) {\n      throw new TypeError(\"the state must be object type\")\n    }\n    if (options.actions && isObject(options.actions)) {\n      const values = Object.values(options.actions)\n      for (const value of values) {\n        if (typeof value !== \"function\") {\n          throw new TypeError(\"the value of actions must be a function\")\n        }\n      }\n      this.actions = options.actions\n    }\n    this.state = options.state\n    this._observe(options.state)\n    this.event = new EventBus()\n    this.eventV2 = new EventBus()\n  }\n\n  _observe(state) {\n    const _this = this\n    Object.keys(state).forEach(key => {\n      let _value = state[key]\n      Object.defineProperty(state, key, {\n        get: function() {\n          return _value\n        },\n        set: function(newValue) {\n          if (_value === newValue) return\n          _value = newValue\n          _this.event.emit(key, _value)\n          _this.eventV2.emit(key, { [key]: _value })\n        }\n      })\n    })\n  }\n\n  onState(stateKey, stateCallback) {\n    const keys = Object.keys(this.state)\n    if (keys.indexOf(stateKey) === -1) {\n      throw new Error(\"the state does not contain your key\")\n    }\n    this.event.on(stateKey, stateCallback)\n\n    // callback\n    if (typeof stateCallback !== \"function\") {\n      throw new TypeError(\"the event callback must be function type\")\n    }\n    const value = this.state[stateKey]\n    stateCallback.apply(this.state, [value])\n  }\n\n  // [\"name\", \"age\"] callback1\n  // [\"name\", \"height\"] callback2\n\n  onStates(statekeys, stateCallback) {\n    const keys = Object.keys(this.state)\n    const value = {}\n    for (const theKey of statekeys) {\n      if (keys.indexOf(theKey) === -1) {\n        throw new Error(\"the state does not contain your key\")\n      }\n      this.eventV2.on(theKey, stateCallback)\n      value[theKey] = this.state[theKey]\n    }\n\n    stateCallback.apply(this.state, [value])\n  }\n\n  offStates(stateKeys, stateCallback) {\n    const keys = Object.keys(this.state)\n    stateKeys.forEach(theKey => {\n      if (keys.indexOf(theKey) === -1) {\n        throw new Error(\"the state does not contain your key\")\n      }\n      this.eventV2.off(theKey, stateCallback)\n    })\n  }\n\n  offState(stateKey, stateCallback) {\n    const keys = Object.keys(this.state)\n    if (keys.indexOf(stateKey) === -1) {\n      throw new Error(\"the state does not contain your key\")\n    }\n    this.event.off(stateKey, stateCallback)\n  }\n\n  setState(stateKey, stateValue) {\n    this.state[stateKey] = stateValue\n  }\n\n  dispatch(actionName, ...args) {\n    if (typeof actionName !== \"string\") {\n      throw new TypeError(\"the action name must be string type\")\n    }\n    if (Object.keys(this.actions).indexOf(actionName) === -1) {\n      throw new Error(\"this action name does not exist, please check it\")\n    }\n    const actionFn = this.actions[actionName]\n    actionFn.apply(this, [this.state, ...args])\n  }\n}\n\nmodule.exports = HYEventStore\n","function isObject(obj) {\n  var type = typeof obj;\n  return type === 'object' && !!obj;\n}\n\nmodule.exports = {\n  isObject\n}"]}